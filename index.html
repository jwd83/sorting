<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: #2c3e50;
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }

        .controls {
            background-color: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            font-weight: 600;
            margin-right: 0.5rem;
            display: flex;
            align-items: center;
        }

        select, input[type="range"] {
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
        }

        select {
            min-width: 150px;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 4px;
            background-color: #3498db;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        button.primary {
            background-color: #2ecc71;
        }

        button.primary:hover {
            background-color: #27ae60;
        }

        button.danger {
            background-color: #e74c3c;
        }

        button.danger:hover {
            background-color: #c0392b;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speed-value {
            min-width: 40px;
            text-align: center;
            font-weight: 600;
        }

        .visualization-container {
            background-color: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .bars-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 400px;
            gap: 2px;
            margin-top: 1rem;
        }

        .bar {
            flex: 1;
            background-color: #3498db;
            transition: height 0.3s, background-color 0.3s;
            border-radius: 3px 3px 0 0;
            position: relative;
        }

        .bar.comparing {
            background-color: #f39c12;
        }

        .bar.swapping {
            background-color: #e74c3c;
        }

        .bar.sorted {
            background-color: #2ecc71;
        }

        .bar.pivot {
            background-color: #9b59b6;
        }

        .bar.merging {
            background-color: #e67e22;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 0.25rem;
        }

        .algorithm-info {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }

        .algorithm-info h3 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .algorithm-info p {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .complexity {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .complexity-item {
            font-size: 0.85rem;
        }

        .complexity-item span {
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .control-group {
                flex-direction: column;
            }
            
            .bars-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Sorting Algorithm Visualizer</h1>
        <p class="subtitle">Watch how different sorting algorithms work step by step</p>
    </header>
    
    <main>
        <section class="controls">
            <div class="control-group">
                <label for="algorithm">Algorithm:</label>
                <select id="algorithm">
                    <option value="bubble">Bubble Sort</option>
                    <option value="selection">Selection Sort</option>
                    <option value="insertion">Insertion Sort</option>
                    <option value="merge">Merge Sort</option>
                    <option value="quick">Quick Sort</option>
                    <option value="heap">Heap Sort</option>
                </select>
                
                <label for="array-size">Array Size:</label>
                <select id="array-size">
                    <option value="10">10</option>
                    <option value="20">20</option>
                    <option value="30">30</option>
                    <option value="40">40</option>
                    <option value="50">50</option>
                    <option value="64" selected>64</option>
                </select>
                
                <div class="speed-control">
                    <label for="speed">Speed:</label>
                    <input type="range" id="speed" min="1" max="100" value="50">
                    <span class="speed-value">50</span>
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="generate" class="primary">Generate New Array</button>
                    <button id="shuffle">Shuffle</button>
                    <button id="sort">Sort</button>
                    <button id="pause" disabled>Pause</button>
                    <button id="step" disabled>Step</button>
                    <button id="reset" class="danger">Reset</button>
                </div>
            </div>
        </section>
        
        <section class="visualization-container">
            <div class="bars-container" id="bars-container"></div>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="comparisons">0</div>
                    <div class="stat-label">Comparisons</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="swaps">0</div>
                    <div class="stat-label">Swaps</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="time">0.00s</div>
                    <div class="stat-label">Time Elapsed</div>
                </div>
            </div>
            
            <div class="algorithm-info" id="algorithm-info">
                <h3>Bubble Sort</h3>
                <p>Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</p>
                <div class="complexity">
                    <div class="complexity-item">Time: <span>O(n²)</span></div>
                    <div class="complexity-item">Space: <span>O(1)</span></div>
                </div>
            </div>
        </section>
    </main>

    <script>
        class SortingVisualizer {
            constructor() {
                this.array = [];
                this.originalArray = [];
                this.arraySize = 64;
                this.animationSpeed = 50;
                this.isRunning = false;
                this.isPaused = false;
                this.comparisons = 0;
                this.swaps = 0;
                this.startTime = 0;
                this.elapsedTime = 0;
                this.animationFrames = [];
                this.currentFrame = 0;
                this.timer = null;
                
                this.initElements();
                this.initEventListeners();
                this.generateRandomArray();
                this.renderBars();
                this.updateAlgorithmInfo();
            }
            
            initElements() {
                this.barsContainer = document.getElementById('bars-container');
                this.algorithmSelect = document.getElementById('algorithm');
                this.arraySizeSelect = document.getElementById('array-size');
                this.speedSlider = document.getElementById('speed');
                this.speedValue = document.querySelector('.speed-value');
                this.generateBtn = document.getElementById('generate');
                this.shuffleBtn = document.getElementById('shuffle');
                this.sortBtn = document.getElementById('sort');
                this.pauseBtn = document.getElementById('pause');
                this.stepBtn = document.getElementById('step');
                this.resetBtn = document.getElementById('reset');
                this.comparisonsEl = document.getElementById('comparisons');
                this.swapsEl = document.getElementById('swaps');
                this.timeEl = document.getElementById('time');
                this.algorithmInfo = document.getElementById('algorithm-info');
            }
            
            initEventListeners() {
                this.generateBtn.addEventListener('click', () => {
                    this.reset();
                    this.generateRandomArray();
                    this.renderBars();
                });
                
                this.shuffleBtn.addEventListener('click', () => {
                    this.reset();
                    this.shuffleArray();
                    this.renderBars();
                });
                
                this.sortBtn.addEventListener('click', () => {
                    this.startSorting();
                });
                
                this.pauseBtn.addEventListener('click', () => {
                    this.togglePause();
                });
                
                this.stepBtn.addEventListener('click', () => {
                    this.stepForward();
                });
                
                this.resetBtn.addEventListener('click', () => {
                    this.reset();
                    this.renderBars();
                });
                
                this.algorithmSelect.addEventListener('change', () => {
                    this.updateAlgorithmInfo();
                });
                
                this.arraySizeSelect.addEventListener('change', (e) => {
                    this.arraySize = parseInt(e.target.value);
                    this.reset();
                    this.generateRandomArray();
                    this.renderBars();
                });
                
                this.speedSlider.addEventListener('input', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                    this.speedValue.textContent = this.animationSpeed;
                });
            }
            
            generateRandomArray() {
                this.array = [];
                for (let i = 0; i < this.arraySize; i++) {
                    this.array.push(Math.floor(Math.random() * 400) + 10);
                }
                this.originalArray = [...this.array];
            }
            
            shuffleArray() {
                for (let i = this.array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                }
                this.originalArray = [...this.array];
            }
            
            renderBars() {
                this.barsContainer.innerHTML = '';
                const maxValue = Math.max(...this.array);
                
                for (let i = 0; i < this.array.length; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = `${(this.array[i] / maxValue) * 100}%`;
                    bar.dataset.index = i;
                    this.barsContainer.appendChild(bar);
                }
            }
            
            updateBars(indices, className) {
                const bars = this.barsContainer.querySelectorAll('.bar');
                indices.forEach(i => {
                    if (bars[i]) {
                        bars[i].className = `bar ${className}`;
                    }
                });
            }
            
            updateBar(index, value) {
                const bars = this.barsContainer.querySelectorAll('.bar');
                if (bars[index]) {
                    const maxValue = Math.max(...this.array);
                    bars[index].style.height = `${(value / maxValue) * 100}%`;
                }
            }
            
            markSorted(indices) {
                const bars = this.barsContainer.querySelectorAll('.bar');
                indices.forEach(i => {
                    if (bars[i]) {
                        bars[i].classList.add('sorted');
                    }
                });
            }
            
            clearHighlights() {
                const bars = this.barsContainer.querySelectorAll('.bar');
                bars.forEach(bar => {
                    if (!bar.classList.contains('sorted')) {
                        bar.className = 'bar';
                    }
                });
            }
            
            startSorting() {
                if (this.isRunning) return;
                
                this.reset();
                this.isRunning = true;
                this.startTime = Date.now();
                this.updateTimer();
                
                this.generateBtn.disabled = true;
                this.shuffleBtn.disabled = true;
                this.sortBtn.disabled = true;
                this.arraySizeSelect.disabled = true;
                this.pauseBtn.disabled = false;
                this.stepBtn.disabled = true;
                
                const algorithm = this.algorithmSelect.value;
                
                switch (algorithm) {
                    case 'bubble':
                        this.bubbleSort();
                        break;
                    case 'selection':
                        this.selectionSort();
                        break;
                    case 'insertion':
                        this.insertionSort();
                        break;
                    case 'merge':
                        this.mergeSort();
                        break;
                    case 'quick':
                        this.quickSort();
                        break;
                    case 'heap':
                        this.heapSort();
                        break;
                }
                
                this.playAnimation();
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                this.pauseBtn.textContent = this.isPaused ? 'Resume' : 'Pause';
                this.stepBtn.disabled = !this.isPaused;
                
                if (this.isPaused) {
                    clearInterval(this.timer);
                } else {
                    this.playAnimation();
                }
            }
            
            stepForward() {
                if (this.currentFrame < this.animationFrames.length) {
                    this.executeFrame(this.animationFrames[this.currentFrame]);
                    this.currentFrame++;
                    
                    if (this.currentFrame >= this.animationFrames.length) {
                        this.finishSorting();
                    }
                }
            }
            
            playAnimation() {
                if (this.timer) clearInterval(this.timer);
                
                // Calculate delay with 10x faster max speed
                // Speed 1: 100ms delay
                // Speed 100: 0.1ms delay (10x faster than before)
                const delay = Math.max(0.1, 100 * Math.pow(0.1, (this.animationSpeed - 1) / 99));
                
                this.timer = setInterval(() => {
                    if (this.currentFrame >= this.animationFrames.length) {
                        this.finishSorting();
                        return;
                    }
                    
                    this.executeFrame(this.animationFrames[this.currentFrame]);
                    this.currentFrame++;
                }, delay);
            }
            
            executeFrame(frame) {
                this.clearHighlights();
                
                if (frame.comparing) {
                    this.updateBars(frame.comparing, 'comparing');
                    this.comparisons++;
                    this.comparisonsEl.textContent = this.comparisons;
                }
                
                if (frame.swapping) {
                    this.updateBars(frame.swapping, 'swapping');
                    this.swaps++;
                    this.swapsEl.textContent = this.swaps;
                }
                
                if (frame.merging) {
                    this.updateBars(frame.merging, 'merging');
                }
                
                if (frame.pivot) {
                    this.updateBars([frame.pivot], 'pivot');
                }
                
                if (frame.swap) {
                    const [i, j] = frame.swap;
                    [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                    this.updateBar(i, this.array[i]);
                    this.updateBar(j, this.array[j]);
                }
                
                if (frame.setValue) {
                    const [index, value] = frame.setValue;
                    this.array[index] = value;
                    this.updateBar(index, value);
                }
                
                if (frame.sorted) {
                    this.markSorted(frame.sorted);
                }
            }
            
            finishSorting() {
                clearInterval(this.timer);
                this.isRunning = false;
                this.isPaused = false;
                
                this.generateBtn.disabled = false;
                this.shuffleBtn.disabled = false;
                this.sortBtn.disabled = false;
                this.arraySizeSelect.disabled = false;
                this.pauseBtn.disabled = true;
                this.stepBtn.disabled = true;
                
                this.pauseBtn.textContent = 'Pause';
                
                // Mark all bars as sorted
                const sortedIndices = [];
                for (let i = 0; i < this.array.length; i++) {
                    sortedIndices.push(i);
                }
                this.markSorted(sortedIndices);
            }
            
            reset() {
                clearInterval(this.timer);
                this.isRunning = false;
                this.isPaused = false;
                this.comparisons = 0;
                this.swaps = 0;
                this.elapsedTime = 0;
                this.animationFrames = [];
                this.currentFrame = 0;
                
                // Restore original array
                this.array = [...this.originalArray];
                
                this.comparisonsEl.textContent = '0';
                this.swapsEl.textContent = '0';
                this.timeEl.textContent = '0.00s';
                
                this.generateBtn.disabled = false;
                this.shuffleBtn.disabled = false;
                this.sortBtn.disabled = false;
                this.arraySizeSelect.disabled = false;
                this.pauseBtn.disabled = true;
                this.stepBtn.disabled = true;
                
                this.pauseBtn.textContent = 'Pause';
                
                this.clearHighlights();
            }
            
            updateTimer() {
                if (this.isRunning && !this.isPaused) {
                    this.elapsedTime = (Date.now() - this.startTime) / 1000;
                    this.timeEl.textContent = `${this.elapsedTime.toFixed(2)}s`;
                    requestAnimationFrame(() => this.updateTimer());
                }
            }
            
            updateAlgorithmInfo() {
                const algorithm = this.algorithmSelect.value;
                const info = {
                    bubble: {
                        name: 'Bubble Sort',
                        description: 'Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',
                        time: 'O(n²)',
                        space: 'O(1)'
                    },
                    selection: {
                        name: 'Selection Sort',
                        description: 'Selection Sort divides the input into a sorted and an unsorted region, and repeatedly selects the smallest element from the unsorted region to move to the sorted region.',
                        time: 'O(n²)',
                        space: 'O(1)'
                    },
                    insertion: {
                        name: 'Insertion Sort',
                        description: 'Insertion Sort builds the final sorted array one item at a time by repeatedly inserting the next element into the sorted portion of the array.',
                        time: 'O(n²)',
                        space: 'O(1)'
                    },
                    merge: {
                        name: 'Merge Sort',
                        description: 'Merge Sort divides the array into two halves, recursively sorts them, and then merges the sorted halves.',
                        time: 'O(n log n)',
                        space: 'O(n)'
                    },
                    quick: {
                        name: 'Quick Sort',
                        description: 'Quick Sort picks a pivot element and partitions the array around the pivot, then recursively sorts the sub-arrays.',
                        time: 'O(n log n)',
                        space: 'O(log n)'
                    },
                    heap: {
                        name: 'Heap Sort',
                        description: 'Heap Sort builds a max heap from the array and repeatedly extracts the maximum element to build the sorted array.',
                        time: 'O(n log n)',
                        space: 'O(1)'
                    }
                };
                
                const currentInfo = info[algorithm];
                this.algorithmInfo.innerHTML = `
                    <h3>${currentInfo.name}</h3>
                    <p>${currentInfo.description}</p>
                    <div class="complexity">
                        <div class="complexity-item">Time: <span>${currentInfo.time}</span></div>
                        <div class="complexity-item">Space: <span>${currentInfo.space}</span></div>
                    </div>
                `;
            }
            
            // Sorting Algorithms - FIXED VERSIONS
            bubbleSort() {
                const n = this.array.length;
                const arr = [...this.array];
                
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        this.animationFrames.push({
                            comparing: [j, j + 1]
                        });
                        
                        if (arr[j] > arr[j + 1]) {
                            this.animationFrames.push({
                                swapping: [j, j + 1],
                                swap: [j, j + 1]
                            });
                            // Swap in the working array
                            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        }
                    }
                    
                    this.animationFrames.push({
                        sorted: [n - i - 1]
                    });
                }
                
                this.animationFrames.push({
                    sorted: [0]
                });
            }
            
            selectionSort() {
                const n = this.array.length;
                const arr = [...this.array];
                
                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    
                    // Find minimum in unsorted portion
                    for (let j = i + 1; j < n; j++) {
                        this.animationFrames.push({
                            comparing: [minIdx, j]
                        });
                        
                        if (arr[j] < arr[minIdx]) {
                            minIdx = j;
                        }
                    }
                    
                    // Swap minimum with first unsorted element
                    if (minIdx !== i) {
                        this.animationFrames.push({
                            swapping: [i, minIdx],
                            swap: [i, minIdx]
                        });
                        // Swap in the working array
                        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    }
                    
                    // Mark the position as sorted
                    this.animationFrames.push({
                        sorted: [i]
                    });
                }
                
                // Mark last element as sorted
                this.animationFrames.push({
                    sorted: [n - 1]
                });
            }
            
            insertionSort() {
                const n = this.array.length;
                const arr = [...this.array];
                
                for (let i = 1; i < n; i++) {
                    let key = arr[i];
                    let j = i - 1;
                    
                    while (j >= 0 && arr[j] > key) {
                        this.animationFrames.push({
                            comparing: [j, j + 1]
                        });
                        
                        this.animationFrames.push({
                            swapping: [j, j + 1],
                            swap: [j, j + 1]
                        });
                        
                        arr[j + 1] = arr[j];
                        j--;
                    }
                    
                    arr[j + 1] = key;
                    
                    for (let k = 0; k <= i; k++) {
                        this.animationFrames.push({
                            sorted: [k]
                        });
                    }
                }
            }
            
            mergeSort() {
                const arr = [...this.array];
                
                const merge = (left, mid, right) => {
                    const leftArr = arr.slice(left, mid + 1);
                    const rightArr = arr.slice(mid + 1, right + 1);
                    
                    let i = 0, j = 0, k = left;
                    
                    while (i < leftArr.length && j < rightArr.length) {
                        this.animationFrames.push({
                            comparing: [left + i, mid + 1 + j]
                        });
                        
                        if (leftArr[i] <= rightArr[j]) {
                            arr[k] = leftArr[i];
                            this.animationFrames.push({
                                merging: [k],
                                setValue: [k, leftArr[i]]
                            });
                            i++;
                        } else {
                            arr[k] = rightArr[j];
                            this.animationFrames.push({
                                merging: [k],
                                setValue: [k, rightArr[j]]
                            });
                            j++;
                        }
                        k++;
                    }
                    
                    while (i < leftArr.length) {
                        arr[k] = leftArr[i];
                        this.animationFrames.push({
                            merging: [k],
                            setValue: [k, leftArr[i]]
                        });
                        i++;
                        k++;
                    }
                    
                    while (j < rightArr.length) {
                        arr[k] = rightArr[j];
                        this.animationFrames.push({
                            merging: [k],
                            setValue: [k, rightArr[j]]
                        });
                        j++;
                        k++;
                    }
                };
                
                const mergeSortRecursive = (left, right) => {
                    if (left < right) {
                        const mid = Math.floor((left + right) / 2);
                        mergeSortRecursive(left, mid);
                        mergeSortRecursive(mid + 1, right);
                        merge(left, mid, right);
                        
                        // Mark merged section as sorted
                        for (let idx = left; idx <= right; idx++) {
                            this.animationFrames.push({
                                sorted: [idx]
                            });
                        }
                    }
                };
                
                mergeSortRecursive(0, arr.length - 1);
            }
            
            quickSort() {
                const arr = [...this.array];
                
                const partition = (low, high) => {
                    const pivot = arr[high];
                    this.animationFrames.push({
                        pivot: high
                    });
                    
                    let i = low - 1;
                    
                    for (let j = low; j < high; j++) {
                        this.animationFrames.push({
                            comparing: [j, high]
                        });
                        
                        if (arr[j] < pivot) {
                            i++;
                            
                            if (i !== j) {
                                this.animationFrames.push({
                                    swapping: [i, j],
                                    swap: [i, j]
                                });
                                // Swap in the working array
                                [arr[i], arr[j]] = [arr[j], arr[i]];
                            }
                        }
                    }
                    
                    if (i + 1 !== high) {
                        this.animationFrames.push({
                            swapping: [i + 1, high],
                            swap: [i + 1, high]
                        });
                        // Swap in the working array
                        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                    }
                    
                    this.animationFrames.push({
                        sorted: [i + 1]
                    });
                    
                    return i + 1;
                };
                
                const quickSortRecursive = (low, high) => {
                    if (low < high) {
                        const pi = partition(low, high);
                        quickSortRecursive(low, pi - 1);
                        quickSortRecursive(pi + 1, high);
                    } else if (low === high) {
                        this.animationFrames.push({
                            sorted: [low]
                        });
                    }
                };
                
                quickSortRecursive(0, arr.length - 1);
            }
            
            heapSort() {
                const arr = [...this.array];
                const n = arr.length;
                
                const heapify = (n, i) => {
                    let largest = i;
                    const left = 2 * i + 1;
                    const right = 2 * i + 2;
                    
                    if (left < n) {
                        this.animationFrames.push({
                            comparing: [largest, left]
                        });
                        
                        if (arr[left] > arr[largest]) {
                            largest = left;
                        }
                    }
                    
                    if (right < n) {
                        this.animationFrames.push({
                            comparing: [largest, right]
                        });
                        
                        if (arr[right] > arr[largest]) {
                            largest = right;
                        }
                    }
                    
                    if (largest !== i) {
                        this.animationFrames.push({
                            swapping: [i, largest],
                            swap: [i, largest]
                        });
                        // Swap in the working array
                        [arr[i], arr[largest]] = [arr[largest], arr[i]];
                        
                        heapify(n, largest);
                    }
                };
                
                // Build max heap
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    heapify(n, i);
                }
                
                // Extract elements from heap
                for (let i = n - 1; i > 0; i--) {
                    this.animationFrames.push({
                        swapping: [0, i],
                        swap: [0, i]
                    });
                    // Swap in the working array
                    [arr[0], arr[i]] = [arr[i], arr[0]];
                    
                    this.animationFrames.push({
                        sorted: [i]
                    });
                    
                    heapify(i, 0);
                }
                
                this.animationFrames.push({
                    sorted: [0]
                });
            }
        }
        
        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SortingVisualizer();
        });
    </script>
</body>
</html>
